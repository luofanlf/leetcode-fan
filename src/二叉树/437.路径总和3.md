# 437.路径总和3

https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    //key：从root开始的累加值，value：该值的出现次数
    Map<Long,Integer> map = new HashMap<>();
    int target;

    public int pathSum(TreeNode root, int targetSum) {
        target = targetSum;
        //使得从root开始的刚好等于target的可以被统计
        map.put(0L,1);

        return suffix(root,0);
    }

    public int suffix(TreeNode node,long curSum){
        if(node == null){
            return 0;
        }
        
        int res = 0;
        curSum += node.val;
        
        //以当前节点为终点的result，寻找符合target的起点
        res+=map.getOrDefault(curSum-target,0);
        map.put(curSum,map.getOrDefault(curSum,0)+1);

        int left = suffix(node.left,curSum);
        int right = suffix(node.right,curSum);

        res = res+left+right;

        map.put(curSum,map.get(curSum)-1);

        return res;
        
    }
    
}
```

前缀和：暴力的解法是两层递归，先遍历一遍整个树对于每个节点作为起点，递归向下去寻找一个终点节点使得路径sum等于target。优化的思路是用哈希表来记录前缀和从而将寻找起点的复杂度优化到O(1),维护一个哈希表，key表示从root开始到当前节点的前缀和，value代表当前前缀和出现的次数，首先先往map中存入（0，1）因为对应刚好是到根节点的sum等于target的情况，然后遍历到每个节点时，更新currentSum寻找map中前缀和等于curSum-target（即该节点到当前节点path sum等于target）的解，由此达到了优化寻找起点的目的，然后递归遍历左节点和右节点更新res，当遍历完左右节点即以当前节点为root的整颗子树以后需要进行状态恢复（为何要进行状态恢复：因为当前节点的前缀和不能用于其兄弟节点，不符合只能从上到下的路径）
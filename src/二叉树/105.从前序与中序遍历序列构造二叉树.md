# 105.从前序与中序遍历序列构造二叉树

https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i = 0;i<inorder.length;i++){
            map.put(inorder[i],i);
        }
        TreeNode root = build(map,preorder,0,inorder.length-1,0);

        return root;

    }
    //leftEdge:上一个root在inorder中的index
    //preIndex:当前节点在preorder中的index
    public TreeNode build(Map<Integer,Integer> map,int[] preorder,int leftEdge,int rightEdge,int preIndex){
        int rootVal = preorder[preIndex];
        int index = map.get(rootVal);
        TreeNode node = new TreeNode(rootVal);
        int leftSize = index-leftEdge;
        int rightSize = rightEdge-index;

        int leftIndex = preIndex+1;
        int rightIndex = preIndex+leftSize+1;

        if(leftSize > 0){
            node.left = build(map,preorder,leftEdge,index-1,leftIndex);
        }
        if(rightSize > 0){
            node.right = build(map,preorder,index+1,rightEdge,rightIndex);
        }


        return node;
        
    }
}
```

法1:递归，首先先序遍历的第一个节点为根节点，将中序遍历存储到map中为值-index的键值对，然后通过先序遍历中根节点的值确定其在中序遍历中的位置，从而可以得知其左子树和右子树的size，通过这个size我们又可以反过来到先序遍历中找到左子树和右子树的根节点，从而可以运用递归从上至下构建整个树

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        Deque<TreeNode> stack = new ArrayDeque<>();
        int index = 0;
        TreeNode root = new TreeNode(preorder[0]);
        stack.push(root);
        for(int i = 1;i<preorder.length;i++){
            int preorderVal = preorder[i];
            if(inorder[index]!=stack.peek().val){
                TreeNode node = new TreeNode(preorderVal);
                stack.peek().left = node;
                stack.push(node);
            }else{
                TreeNode parent = null;
                while(!stack.isEmpty()&&inorder[index]==stack.peek().val){
                    parent = stack.pop();
                    index++;
                }
                TreeNode rightChild = new TreeNode(preorderVal);
                parent.right = rightChild;
                stack.push(rightChild); 
            }
        }
        return root;
    }
}
```

法2：迭代，前序遍历中，对于连续的两个节点x,y一定属于两种情况之一，1：y是x的左节点；2:x没有子节点了，y是x的某个祖先节点的右节点。因此建立一个栈，首先将根节点入栈并且建立一个preorderIndex的索引初始化为0。preorderindex是最左的一个节点，因此在遍历中序遍历时，如果栈顶不等于index对应的值说明还有左节点可遍历，将当前节点入栈；如果发现当前节点等于栈顶节点了，说明该节点为栈中某个节点的右节点，要想找到这个节点：先序遍历是“根-左-右”，中序遍历是“左-根-右”，所以这个节点在中序遍历中会被夹在栈中的元素中，因此如果栈顶元素等于index对应元素且stack不为空就弹出栈顶元素并且++index，最后一个弹出的栈顶元素就是当前节点的父节点。
# 105.从前序与中序遍历序列构造二叉树

https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i = 0;i<inorder.length;i++){
            map.put(inorder[i],i);
        }
        TreeNode root = build(map,preorder,0,inorder.length-1,0);

        return root;

    }
    //leftEdge:上一个root在inorder中的index
    //preIndex:当前节点在preorder中的index
    public TreeNode build(Map<Integer,Integer> map,int[] preorder,int leftEdge,int rightEdge,int preIndex){
        int rootVal = preorder[preIndex];
        int index = map.get(rootVal);
        TreeNode node = new TreeNode(rootVal);
        int leftSize = index-leftEdge;
        int rightSize = rightEdge-index;

        int leftIndex = preIndex+1;
        int rightIndex = preIndex+leftSize+1;

        if(leftSize > 0){
            node.left = build(map,preorder,leftEdge,index-1,leftIndex);
        }
        if(rightSize > 0){
            node.right = build(map,preorder,index+1,rightEdge,rightIndex);
        }


        return node;
        
    }
}
```

法1:递归，首先先序遍历的第一个节点为根节点，将中序遍历存储到map中为值-index的键值对，然后通过先序遍历中根节点的值确定其在中序遍历中的位置，从而可以得知其左子树和右子树的size，通过这个size我们又可以反过来到先序遍历中找到左子树和右子树的根节点，从而可以运用递归从上至下构建整个树
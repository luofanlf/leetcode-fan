# 124.二叉树中的最大路径和

https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    private int maxPathSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        getMaxNodeSum(root);
        return maxPathSum;
    }

    public int getMaxNodeSum(TreeNode node){
        if(node == null){
            return 0;
        }
    
        int leftGain = Math.max(getMaxNodeSum(node.left),0);
        int rightGain = Math.max(getMaxNodeSum(node.right),0);

      	//用于找到最大路径和
        int currGain = leftGain + rightGain + node.val;
        if(currGain>maxPathSum){
            maxPathSum = currGain;
        }

      	//用于递归传递gain
        return node.val+Math.max(leftGain,rightGain);
    }
}
```

递归，对于以每个节点为转折点的最大路径和等于左子树最大路径和加上右子树最大路径和再加上当前节点值，声明一个全局变量用于记录最大的路径和，因为递归是自下而上，所以在leftGain或者rightGain小于0时把这个路径剪枝掉：``Math.max(getMaxNodeSum(node.left),0)``，并且在往上抛gain的时候 因为不以node作为转折点，所以只能选择left或right一边的gain，故有``node.val+Math.max(leftGain,rightGain)``


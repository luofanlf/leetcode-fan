# 41.缺失的第一个正数.md

https://leetcode.cn/problems/first-missing-positive/solutions/304743/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        //原地哈希，索引i处存等于i+1的值，第一个存储值不等于i+1的就是缺失值
        int n = nums.length;
        for(int i = 0;i<nums.length;i++){
            while(nums[i]>0&&nums[i]<=n&&nums[i] != nums[nums[i]-1]){
                //swap
                int swap = nums[nums[i]-1];
                nums[nums[i]-1] = nums[i];
                nums[i] = swap;
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
    }
}
```

原地哈希，交换数组中的数，使得索引为i处存储的数为i+1，最后遍历数组一个索引i处不等于i+1的则i+1则为缺失的第一个正数。在交换的过程中，对于长度为n的数组，其缺失的数一定在1-n+1之间，所以我们只需要交换数组中1-n间的数即可，此外需要用nums[i] != nums[nums[i]-1]来判断是否需要进行交换，如果用i!=nums[i]-1的话会在[1,1]的情况下陷入死循环，必须让交换的目标位置nums[i]目前不等于i+1，如果最后全部有序，数组包含了1-n之间所有正数，则返回n+1

2️⃣ 为什么是**nums[i] != nums[nums[i]-1]**

- nums[i] 是当前的数字
- nums[i]-1 是它应该放置的目标索引
- nums[nums[i]-1] 是目标索引上的数字
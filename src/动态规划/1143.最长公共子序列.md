# [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

```java
class Solution {
    /** 
     dp[i][j] - text1[0..i]和text2[0..j]拥有的公共子序列长度
     if(text[i] == text[j] dp[i][j] = dp[i-1][j-1]+1) else:dp[i][j] = max(dp[i-1][j],dp[i][j-1])
     */
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m][n];

        if(text1.charAt(0)==text2.charAt(0)){
                dp[0][0] = 1;
        }
        for(int i = 1;i<m;i++){
            if(text1.charAt(i)==text2.charAt(0)){
                dp[i][0] = 1;
            }
            else{
                dp[i][0] = dp[i-1][0];
            }
        }
        for(int j = 1;j<n;j++){
            if(text1.charAt(0)==text2.charAt(j)){
                dp[0][j] = 1;
            }
            else{
                dp[0][j] = dp[0][j-1];
            }
        }
        
        
        for(int i = 1;i<m;i++){
            for(int j = 1;j<n;j++){
                if(text1.charAt(i)==text2.charAt(j)){
                    dp[i][j] = dp[i-1][j-1]+1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }

        return dp[m-1][n-1];
    }
}
```

动态规划，dp数组代表text1[0..i]和text2[0..j]拥有的公共子序列长度，在计算公共子序列的时候，如果两个text只有其中一个计算的长度增加，那么公共子序列应该是不会变化的，所以动态转移方程如下：在text[i]和text[j]相等时，``dp[i][j]``等于``dp[i-1][j-1]+1``，若不相等则等于``Math.max(dp[i-1][j],dp[i][j-1])``。在初始化时，比较text1[0],text2[0]来初始化``dp[0][0]``,然后分别初始化``dp[0..i][0]``，只要text1中有一个字母等于text2[0]，那么从该字母开始的``dp[0..i][0]``都应该等于1；对于text2的``dp[0][0..j]``的初始化同理
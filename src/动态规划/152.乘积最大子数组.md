# 152.乘积最大子数组

https://leetcode.cn/problems/maximum-product-subarray/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    /**
    dp_max[n] - 数组nums中前n+1个数中以索引n结尾的乘积最大值
    dp_min[n] - 数组nums中前n+1个数中以索引n结尾的乘积最小值
     */
    public int maxProduct(int[] nums) {
        //定义dp数组
        int[] dp_max = new int[nums.length];
        int[] dp_min = new int[nums.length];
        int result = nums[0];
        //初始化
        dp_max[0] = nums[0];
        dp_min[0] = nums[0];
        //状态转移
        for(int i = 1;i<nums.length;i++){
            dp_max[i] = Math.max(nums[i],Math.max(dp_max[i-1]*nums[i],dp_min[i-1]*nums[i]));
            dp_min[i] = Math.min(nums[i],Math.min(dp_max[i-1]*nums[i],dp_min[i-1]*nums[i]));
            result = Math.max(result,dp_max[i]);
        }
        return result;
    }
}
```

因为受连续条件制约，所以定义转移方程时需要定义“以n结尾的子数组”，这样在状态转移的时候满足连续条件。因为考虑到nums[i]可能为正数或者负数，因此最大值可能是当nums[i]为正时的max * nums[i] 或者为负时的min * nums[i]。因此需要维护两个数组dp_max和dp_min。在数组中，0是一个比较特殊的情况，对于nums[i]，如果nums[i-1]为0，之前的子数组乘积就会变成0需要被舍弃，nums[i]会成为dp_max或dp_min,因此可以得到状态转移方程有

`` dp_max[i] = Math.max(nums[i],Math.max(dp_max[i-1]*nums[i],dp_min[i-1]*nums[i]));
dp_min[i] = Math.min(nums[i],Math.min(dp_max[i-1]*nums[i],dp_min[i-1]*nums[i]));``
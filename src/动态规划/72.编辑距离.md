# [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

```java
class Solution {
    /**
    dp[i][j] -  word的前i个字符转换到word2前j个字符所需最少操作数
    if word[i]==word[j]: dp[i][j]= dp[i-1][j-1]
    else: Math.min(dp[i-1][j-1]+1-替换,dp[i-1][j]+1-删除,dp[i][j-1]+1-增加)
     */
    public int minDistance(String word1, String word2) {
        
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m+1][n+1];

        for(int i = 1;i<=m;i++){
            dp[i][0] = dp[i-1][0]+1;
        }
        for(int j = 1;j<=n;j++){
            dp[0][j] = dp[0][j-1]+1;
        }

        for(int i = 1;i<=m;i++){
            for(int j = 1;j<=n;j++){
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = Math.min(dp[i-1][j-1]+1,Math.min(dp[i-1][j]+1,dp[i][j-1]+1));
                }
            }
        }
        return dp[m][n];
    }
}
```

对于dp数组的定义``dp[i][j] -  word的前i个字符转换到word2前j个字符所需最少操作数``,动态转移方程，如果``word1[i]==word2[j]``那么``dp[i][j]= dp[i-1][j-1]``,如果不想等，那么``dp[i][j]``可以由三种情况推导而来,1.替换：如果从word1[i-1]到word2[j-1]需要``dp[i-1][j-1]``步，那么只需要多一步把word1[i]替换成word2[j]; 2.删除：从word1[i-1]到word2[j]需要``dp[i-1][j]``步，因此``dp[i][j]``只需要多一步删除word1[i]就可以达到这个效果，因此``dp[i][j]= dp[i-1][j]+1``3.增加：从word1[i]到word2[j-1]需要``dp[i][j-1]``步，那么只需要增加一个word2[j]就可以满足。综上：``if word[i]==word[j]: dp[i][j]= dp[i-1][j-1]
    else: Math.min(dp[i-1][j-1]+1-替换,dp[i-1][j]+1-删除,dp[i][j-1]+1-增加)``

初始化对于两个word的前0位都无需操作，对于其中一个word的增长只需要每增加1的长度就加一即可（增加或删除）


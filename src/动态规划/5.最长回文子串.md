# [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

```java
class Solution {
    /**
        dp[m][n]- m开头，n结尾的是否是回文串
        dp[m][n] = dp[m+1][n-1] && s[m] == s[n]
     */
    public String longestPalindrome(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int curMaxLength = 1;
        String res = s.substring(0,1);
        for(int i = 0;i<n;i++){
            dp[i][i]= true;
            if(i!=n-1){
                if(s.charAt(i)==s.charAt(i+1)){
                    dp[i][i+1] = true;
                    curMaxLength = 2;
                    res = s.substring(i,i+2);
                }
            }
        }

        //遍历长度
        for(int i = 2;i<n;i++){
            //遍历起点
            for(int j = 0;j<n-i;j++){
                dp[j][j+i] = dp[j+1][j+i-1] && s.charAt(j)== s.charAt(j+i);
                if(dp[j][j+i]&&((i+1)>curMaxLength)){
                    curMaxLength = i+1;
                    res = s.substring(j,j+i+1);
                }
            }
        }
        return res;
    }
}
```

动态规划，对于寻找回文子串，要遍历开头和结尾确定子串是O(n^2)的时间复杂复杂度，判断是否是回文串又需要O(n)的时间复杂度，但是我们可以通过动态规划将判断是否是回文串的复杂度降到O(1)，对于回文串“xabax”可以通过已有的回文串“aba”加上x=x的到，因此我们申明dp boolean数组表示m开头，n结尾的是否是回文串，动态转移方程是``dp[m][n] = dp[m+1][n-1] && s[m] == s[n]``。dp数组的填表顺序应该是从长度小的子串->长度长的子串，因此我们先初始化长度1，2的数组，然后在开始填表，外层遍历长度，内层遍历起点，满足回文子串的就更新res
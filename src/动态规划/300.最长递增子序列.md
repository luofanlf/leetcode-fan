# 300.最长递增子序列

https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    /**
    dp[i] - 数组nums前i+1个元素,并且以索引i为结尾的最长递增子序列长度
     */
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int res = 1;
        for(int i = 1;i<nums.length;i++){
            dp[i] = 1;
            for(int j = 0;j<i;j++){
                if(nums[j]<nums[i]){
                   dp[i] = Math.max(dp[i],dp[j]+1);
                } 
            }
            res = Math.max(res,dp[i]);
        }
        return res;
    }
}
```

1.动态规划：

在拆分子问题得到dp数组的定义时，在拆小问题时，**当前元素是否被包含**会直接影响子问题的定义：

1. 如果当前元素被包含 → 状态需要记录“包含当前元素时的最优解”
2. 如果当前元素不被包含 → 可以直接使用之前的状态

在这道题当中，如果直接定义dp[n]为数组nums前n+1个元素的，则很难在递推中处理当前元素是否包含在LIS中这个条件，因此定义为dp[i] - 数组nums前i+1个元素,并且以索引i为结尾的最长递增子序列长度，这样对于每个dp[i]只要有j<i&&nums[j]<nums[i]，则可以得到dp[i] = dp[j]+1,因此遍历i得到每个以i结尾的LIS最长值然后取其中最大的dp[i]

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
    	int[] g = new int[nums.length];
      g[0] = nums[0];
      int len = 1;
      for(int i = 0;i< nums.length;i++){
        //如果大于g末尾元素，将当前元素加入g中
        if(nums[i]>g[len-1]){
         	g[len] = nums[i];
          len++;
        }else{
          //否则找到g中第一个大于等于nums[i]的元素
          int left = 0;
          int right = len-1;
          while(left<=right){
            int mid = left+(right-left)/2;
            if(g[mid] < nums[i]){
                left = mid + 1;
            } else {
                right = mid - 1;
            }
          }
          g[left] = nums[i];
        }
      }
    return len;
    }
}
```

2.贪心+二分搜索

定义g[i]为长度为i+1的LIS的末尾元素的最小值

遍历nums，两种情况，如果当前元素大于g末尾元素，将当前元素加入数组中；否则找到g第一个大于等于当前元素的元素（二分）并替换他（对于这个位置的前一个position的元素，当前元素一定大于他，因此可以和他组成长度比其大1的LIS，符合数组g的定义）

例如nums = [1,6,7,2,4,5,3]

g = [1]  -> g = [1,6] -> g = [1,6,7] -> g=[1,2,7] -> g = [1,2,4] -> g = [1,2,4,5] -> g = [1,2,4,5]

用了贪心的思想使每个长度下的末尾元素最小——使得更有可能添加元素进LIS中

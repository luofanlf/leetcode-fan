# 198.打家劫舍

https://leetcode.cn/problems/house-robber/solutions/263856/da-jia-jie-she-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    /** 
        dp[n] - 在前n个房间能偷到的最高金额
        状态转移方程 - dp[n] = Math.max(dp[n-1],dp[n-2]+nums[n])
    */
    public int rob(int[] nums) {
        int[] dp = new int[nums.length];
        if(nums.length == 1){
            return nums[0];
        }
        if(nums.length == 2){
            return Math.max(nums[0],nums[1]);
        }
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        for(int i = 2;i<nums.length;i++){
            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp[nums.length-1];
    }
}
```

动态规划： dp[n] - 在前n个房间能偷到的最高金额，状态转移方程 - dp[n] = Math.max(dp[n-1],dp[n-2]+nums[n])

按小偷从左偷到右来考虑，对于在某个房子n时，有偷或者不偷两种选择，如果选择偷则不能偷他的前一个房子，因此金额等于dp[n-2]+nums[n]；如果不偷金额则为dp[n-1]；在两者中取大值则为dp[n]。为防止数组越界，一个房子时直接返回该房子的金额；两个房子的时候偷其中金额较大的。
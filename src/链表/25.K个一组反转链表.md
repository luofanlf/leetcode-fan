# 25.K个一组反转链表

https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0,head);
        ListNode pre = dummy;
        while(head != null){
            ListNode tail = pre;
            //判断剩余够不够k个
            for(int i=0;i<k;i++){
                tail=tail.next;
                if(tail==null){
                    return dummy.next;
                } 
            }
            //够k个节点，反转
            ListNode[] reverse = reverse(head,tail);
            head = reverse[0];
            tail = reverse[1];

            pre.next = head;
            pre=tail;
            head=tail.next;

        }
        return dummy.next;
    }
    public ListNode[] reverse(ListNode head,ListNode tail){
        ListNode prev = tail.next;//反转后head接上原tail的下一个节点
        ListNode p = head;
        while(prev!=tail){
            ListNode nextNode = p.next;
            p.next = prev;//改变指向
          	//更新移动prev和p
            prev = p;
            p = nextNode;
        }
        return new ListNode[]{tail,head};
    }
}
```

建立哨兵节点，并用pre指针指向dummy，用head遍历链表，每次先一个for判断剩余节点是否大于k，如果没有就返回链表。如果大于k则反转链表，并且将链表的头与尾和原链表链接，更新pre指针和head指针
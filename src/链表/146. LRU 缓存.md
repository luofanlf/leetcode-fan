# [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

```java
class LRUCache {
    private class Node{
        int key;
        int val;
        Node prev;
        Node next;

        public Node(int key, int val) {
            this.key = key;
            this.val = val;
            this.prev = null;
            this.next = null;
        }
    }
    int capacity;
    Map<Integer,Node> map;
    Node head;
    Node tail;

    private void removeNode(Node node){
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void addToTail(Node node){
        Node end = tail.prev;
        end.next = node;
        node.prev = end;
        node.next = tail;
        tail.prev = node;
    }

    private void moveToTail(Node node){
        removeNode(node);
        addToTail(node);
    }
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.map = new HashMap<>();
        this.head = new Node(0,0);
        this.tail = new Node(0,0);
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        if(map.containsKey(key)){
            //move the node to the tail
            Node cur = map.get(key);
            moveToTail(cur);

            return map.get(key).val;
        }
        return -1;
    }
    
    public void put(int key, int value) {
        if(map.containsKey(key)){
            Node node = map.get(key);
            node.val = value;
            moveToTail(node);
            return;
        }
        //小于capacity直接加到链表尾部
        if(map.size()<capacity){
            Node n = new Node(key,value);
            addToTail(n);
            map.put(key,n);
        }else{
            //大于capacity，把头个节点删除，再加到链表尾部
            Node fir = head.next;
            removeNode(fir);
            map.remove(fir.key);

            Node n = new Node(key,value);
            map.put(key,n);
            addToTail(n);
        }
        return;
    }
}
```

双向链表加哈希表，LRU要求在O(1)时间复杂度实现两个操作：查询key和删除特定key并且更新位置，因此用到双向链表，哈希表用来定位，双向链表允许在O(1)删除节点。在LRUCache里定义内部类节点，包含成员变量key,val,prev,next；需要key的原因是在capacity满的时候需要删除head后的第一个节点，需要通过head.next得到这个节点然后再拿到他的key。LRUCache的成员变量则包含哈希表存储键和节点的map对，capacity，头节点和尾节点。

get方法：检验哈希表是否包含key，如果包含则返回，并且将该节点删除移到链表尾

put方法：检验是否包含，如果包含更新val，移到链表尾。如果不包含的话，就check capacity有没有满，没有满直接加到队尾，更新map；满了的话就删除头节点后的第一个节点，更新map，然后再链表尾加上新的节点，更新map。


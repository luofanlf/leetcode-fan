# 131.分割回文串

https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    List<List<String>> res = new ArrayList<>();

    public List<List<String>> partition(String s) {
        List<String> state = new ArrayList<>();
        dfs(state,s,0);
        return res;
    }

    public void dfs(List<String> state,String s,int start){
        if(start==s.length()){
            res.add(new ArrayList(state));
            return;
        }
        //subString(0,i)包括从0-i-1处的字符串
        for(int i = start+1;i<=s.length();i++){
            String choice = s.substring(start,i);
            if(!isPalindrome(choice)){
                continue;
            }
            state.add(choice);

            dfs(state,s,i);

            //回溯
            state.remove(state.size()-1);
        }
    }

    private boolean isPalindrome(String s){
        int left = 0;
        int right = s.length()-1;
        while(left<=right){
            if(s.charAt(left)!=s.charAt(right)){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

回溯，思路是对于字符串s进行分割，在每一次分割的时候我们必须确保分割的左边是回文串，然后继续dfs字符串被分割的右边的位置，通过一个start来记录分割的位置，当start = 字符串长度的时候说明整个字符串被分割成了多个回文子串，可以加入到res中
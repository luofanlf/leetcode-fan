# 78.子集

https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    public List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        List<Integer> state = new ArrayList<>();
        res.add(new ArrayList<>());
        backTrack(state,nums,0);
        return res;
    }
    public void backTrack(List<Integer> state,int[] nums,int start){
      for(int i = start;i<nums.length;i++){
        state.add(nums[i]);
        res.add(new ArrayList<>(state));
        backTrack(state,nums,i+1);
        //回溯（不选i的情况包括在其中，回溯后自动跳过）
        state.remove(state.size()-1);
      }
    }
}
```

回溯，因为希望子集不会有重复例如[1,2],[2,1]的出现，用一个start记录遍历开始的位置，对于递归从i+1开始考虑，回溯只需要移除state中的最后一个值即可,

[1,2,3]

​      /         |      \

​    1          2       3

/    \           \

2     3          3

  \

​    3

就是dfs加回溯，且dfs的开始的位置必须比之前的大

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        res.add(new ArrayList<>()); // 空集
        for (int num : nums) {
            int size = res.size();
            for (int j = 0; j < size; j++) {
                // 拷贝现有子集并添加 num
                List<Integer> newSubset = new ArrayList<>(res.get(j));
                newSubset.add(num);
                res.add(newSubset);
            }
        }
        return res;
    }
}
```

迭代，遍历num，对于每个已有的子集，加上num并且加入res
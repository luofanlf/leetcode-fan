# 79.单词搜索

https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        int w = board.length;
        int h = board[0].length;
        boolean[][] used = new boolean[w][h];
        for(int i = 0;i<w;i++){
            for(int j = 0;j<h;j++){
                boolean found = dfs(board,used,i,j,word,0);
                if(found){
                    return true;
                }
            }
        }
        return false;
    }

    public boolean dfs(char[][] board,boolean[][] used,int i,int j,String word,int index){
        if(index == word.length()){
            return true;
        }
        if(i<0||j<0||i>=board.length||j>=board[0].length||used[i][j]){
            return false;
        }
        if(word.charAt(index) != board[i][j]){
            return false;
        }
        used[i][j] = true;
        boolean found = dfs(board,used,i-1,j,word,index+1)||
                        dfs(board,used,i+1,j,word,index+1)||
                        dfs(board,used,i,j+1,word,index+1)||
                        dfs(board,used,i,j-1,word,index+1);
        
        //回溯
        used[i][j] = false;
        return found;

    }
}
```

回溯，对于单词搜索的过程中，记录当前的位置i，j，一个数组used来记录已经使用过的位置，和一个index来记录当前比对的单词中的位置，对于每一个位置，下一个搜索一定是[i+1,j],[i-1,j],[i,j+1],[i,j-1]这四个选择中的一个，因此要得到当前位置是否能找到word只需要对这四个方向继续dfs，如果数组越界也就是超出board返回，返回false，如果该位置已经被使用，返回false，如果与word.charAt(index)不匹配也返回false，如果word完全匹配，index = word.length，返回true；dfs之后回溯恢复used数组并且往上抛当前的结果。
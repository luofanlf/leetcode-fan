# 51.N皇后

https://leetcode.cn/problems/n-queens/submissions/684340522/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    private List<List<String>> res = new ArrayList<>();
    
    public List<List<String>> solveNQueens(int n) {
        List<String> state = new ArrayList<>();
        boolean[] col = new boolean[n];
        boolean[] diag1 = new boolean[2*n-1];
        boolean[] diag2 = new boolean[2*n-1];
        dfs(col,diag1,diag2,state,0,n);
        return res;
    }

    //diag1代表左上-右下，diag2代表左下-右上,在赋值的时候需要加上n-1的偏移来使索引非负
    public void dfs(boolean[] col,boolean[] diag1,boolean diag2[],List<String> state, int row,int n){
        if(row == n){
            res.add(new ArrayList<>(state));
            return;
        }
        //ideal queen's pos:[row,i]
        for(int i = 0;i<n;i++){
            if(col[i]||diag1[row-i+n-1]||diag2[row+i]){
                continue;
            }

            //update ban
            col[i] = true;
            diag1[row-i+n-1] = true;
            diag2[row+i] = true;

            //update state
            StringBuilder sb = new StringBuilder();
            for (int s = 0; s < n; s++) {
                sb.append('.');
            }
            sb.setCharAt(i, 'Q');
            state.add(sb.toString());

            //dfs
            dfs(col,diag1,diag2,state,row+1,n);

            //backtrack
            col[i] = false;
            diag1[row-i+n-1] = false;
            diag2[row+i] = false;
            state.remove(state.size()-1);

        }
    }
}
```

回溯，反过来思考，我们在放置每一个queen的时候，要保证他的行，列，左下-右上对角线和左上-右下对角线都没有皇后放置，因为我们会从上到下（行）放置queen，因此只需要三个boolean数组来记录列以及两条对角线是否放置了皇后就可以。对于左上-右下对角线，在一条对角线上row-col相同，而且我们希望索引非负，因此加上n-1的偏移，用row-col+n-1作为标识，而左下到右上的对角线，可以直接用row+col标识，其余基本符合回溯框架
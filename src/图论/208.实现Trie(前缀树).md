# [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

```java
class Trie {
    private class TrieNode{
        TrieNode[] next = new TrieNode[26];
        boolean isEnd = false;
    }
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode node = root;
        int l = word.length();
        for(int i = 0;i<l;i++){
            int index = word.charAt(i)-'a';
            if(node.next[index]==null){
                node.next[index] = new TrieNode();
            }
            node = node.next[index];
        }
        node.isEnd = true;
    }
    
    public boolean search(String word) {
        TrieNode node = root;
        int l = word.length();
        for(int i = 0;i<l;i++){
            int index = word.charAt(i)-'a';
            if(node.next[index] != null){
                node = node.next[index];
            }else{
                return false;
            }
        }
        if(!node.isEnd){
            return false;
        }

        return true;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode node = root;
        int l = prefix.length();
        for(int i = 0;i<l;i++){
            int index = prefix.charAt(i)-'a';
            if(node.next[index] != null){
                node = node.next[index];
            }else{
                return false;
            }
        }

        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

前缀树：对于相同的字母可以用公共节点表示,例如app，apple，application

a-p-p

​	-l-i-c-a-t-i-o-n

​	-e

b-a-b-y

​      -t-h

对于前缀树的定义，首先我们需要定义前缀树节点,node有两个成员变量一个是TrieNode数组，用于存放下一个字母的指针，这个数组大小应为26对应26个字母，下一个字母是什么就把TrieNode放在对应索引的位置,还有一个是isEnd用于记录是否是单词的结尾用来Search单词是否存在，首先定义一个空TrieNode root，

insert操作：遍历单词的字母，当前节点从root开始，用prefix.charAt(i)-'a'来确定单词里的字母需要放在哪一个位置，如果该位置为空则建立新的节点，然后每次遍历后更新当前节点，在单词遍历完后，当前节点处于最后一个字母，将isEnd设置为true。

search：从root开始，遍历单词字母，当前节点的next对应的索引不为空（字母存在），并且遍历完后最后一个字母isEnd == true

startWith：与search一样至少一个对isEnd的判断
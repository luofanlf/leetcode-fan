# [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

```java
class Solution {
    public Queue<int[]> q = new ArrayDeque<>();
    public int fresh = 0;
    public int orangesRotting(int[][] grid) {
        
        int m = grid.length;
        int n = grid[0].length;
        //initialize the rotten orange
        
        for(int i = 0;i<m;i++){
            for(int j = 0;j<n;j++){
                if(grid[i][j]==2){
                    q.offer(new int[]{i,j});
                }else if(grid[i][j]==1){
                    fresh++;
                }
            }
        }

        int res = -1;
        while(!q.isEmpty()){
            int size = q.size();
            res++;
            for(int i = 0;i<size;i++){
                int[] point = q.poll();
                propagate(point[0]-1,point[1],grid);
                propagate(point[0]+1,point[1],grid);
                propagate(point[0],point[1]-1,grid);
                propagate(point[0],point[1]+1,grid);
            }
        }

        //check survivor
        if(fresh == 0){
            return Math.max(res,0);
        }
        return -1;
    }
    public void propagate(int i,int j,int[][] grid){
        if(i<0||j<0||i>grid.length-1||j>grid[0].length-1){
            return;
        }
        if(grid[i][j] != 1){
            return;
        }
        grid[i][j] = 2;
        fresh--;
        q.offer(new int[]{i,j});
    }
}
```

因为所有坏橘子是会同时污染周围的橘子，所以需要用到bfs层序遍历，什么一个队列来存储当前时间新腐烂的橘子，存储int[]坐标位置，首先遍历grid把最初的坏橘子存入队列，并且记录好橘子的数量fresh（如果最后>0说明有橘子不会被感染），然后每次污染队列中坏橘子四周的位置，更新fresh更新时间，最后如果没有好橘子，就返回Math.max(res,0)，（可能一开始就没有任何橘子，res=-1美誉被更新）


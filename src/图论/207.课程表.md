# [207. 课程表](https://leetcode.cn/problems/course-schedule/)

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<List<Integer>> list = new ArrayList<>();
        int[] indegree = new int[numCourses];

        //initilize the map
        for(int i = 0;i<numCourses;i++){
            list.add(new ArrayList<>());
        }
        for(int[] p:prerequisites){
            list.get(p[1]).add(p[0]);
            indegree[p[0]]++;
        }

        Queue<Integer> q = new ArrayDeque<>();
        for(int i = 0;i<numCourses;i++){
            if(indegree[i]==0){
                q.offer(i);
            }
        }
        int num = 0;
        while(!q.isEmpty()){
            int size = q.size();
            int cur = q.poll();
            num++;
            List<Integer> next = list.get(cur);
            for(int n :next){
                indegree[n]--;
                if(indegree[n]==0){
                    q.offer(n); 
                }
            }   
        }

        if(num!=numCourses){
                return false;
            }

        return true;
    }
}
```

bfs拓扑排序，声明一个数组来记录每个课程的入度，假如要修课程b需要先修课程a，则有a->b,则有b的入度为1，先声明一个列表来记录课程的映射关系，该链表记录当前课程是哪些课程的先修同时计算所有课程的入度。然后将入度为0的入队，开始bfs，每次将队列里的课程出队，并将记录的num++，以该课程为先修的入度-1，如果入度等于0，则入队。如果有环存在，因为环中的元素互为依赖，因此所有的元素入度都大于1，没有一个可以入队的，因此num不可能与总课程数相等，最后如果num不等于课程数说明没有环存在，返回true。



```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        //store the relationship between cur and pre course
        List<Integer>[] list = new ArrayList[numCourses];
        for(int i = 0;i<numCourses;i++){
            list[i] = new ArrayList<>();
        } 

        for(int[] p: prerequisites){
            list[p[1]].add(p[0]);
        }

        int[] visited = new int[numCourses];

        for(int i = 0;i<numCourses;i++){
            if(visited[i] == 0){
                if(!dfs(visited,list,i)){
                    return false;
                }
            }
        }
        return true;
    }

    public boolean dfs(int[] visited,List<Integer>[] list,int cur){
        //has cycle
        if(visited[cur]==1){
            return false;
        }
        if(visited[cur]==2){
            return true;
        }
        visited[cur]=1;
        for(int pre : list[cur]){
            if(!dfs(visited,list,pre)){
                return false;
            }
        }
        visited[cur] =2;

        return true;
    }
}
```

dfs，首先把所有的课程的先修关系存储下来，因为课程是从0-num连续的，我们可以用一个list数组来存储映射关系，下标是课程号，存储一个以当前课程为先修课程的列表。dfs过程中用一个数组visited来代表访问状态，0代表未访问，1代表正在访问中，2代表访问结束，该课程不存在环，因为课的关系不一定是全部连续的，例如1-2-3  4-5这样，因此遍历所有课，如果状态是0则开启一次dfs。在dfs的过程中，如果访问到的课状态是1，说明该课程在当前dfs中已经访问过，说明有环存在，如果为2，说明该课程以及在别的dfs中被访问过而且证明无环存在。如果为0，则将状态设为1，继续dfs，在dfs结束后将状态设为2，如果有环存在，往上层抛false。
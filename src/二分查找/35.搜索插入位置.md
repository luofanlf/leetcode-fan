# 35.搜索插入位置

https://leetcode.cn/problems/search-insert-position/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            int mid = left+(right-left)/2;
            if(target==nums[mid]){
                return mid;
            }
            if(target<nums[mid]){
                right=mid-1;
            }
            if(target>nums[mid]){
                left=mid+1;
            }
        }
        return left;
    }
}

```

其实本题需要返回的位置就是nums中第一个大于等于target的位置，如果target存在于nums中，正常二分查找返回。如果target不在nums中，在循环结束后，left一定等于right+1：target会处于right的右边，left的左边，所以应当插入left所在位置

##### 为何left在循环结束时一定处于第一个大于等于target的位置？

在整个循环过程中，我们有两个事实一直成立（这是理解关键）：

1. **arr[0..left-1] < target**
   - 左边所有位置都 **小于 target**
   - 因为每次 arr[mid] < target，我们才把 left = mid+1，确保左边都是小于 target 的元素
2. **arr[right+1..n-1] >= target**
   - 右边所有位置都 **大于或等于 target**
   - 因为每次 arr[mid] >= target，我们才把 right = mid-1，确保右边都是 ≥ target 的元素

**循环结束时**，条件是 left > right：

- 根据不变式：
  - arr[0..left-1] < target
  - arr[left..n-1] >= target

所以 left 正好是第一个 ≥ target 的位置。

也就是说，left的左边一定都小于target，right的右边一定都大于等于target，而循环结束时right=left-1
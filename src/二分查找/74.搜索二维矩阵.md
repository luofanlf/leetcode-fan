# 74.搜索二维矩阵

https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int rowNum = matrix.length;
        int colNum = matrix[0].length;
        int i = Integer.MAX_VALUE;
        //首先二分查找找到处在的行
        int leftRow = 0;
        int rightRow = rowNum-1;
        int midRow;
        while(leftRow<=rightRow){
            midRow = leftRow+(rightRow-leftRow)/2;
            if (matrix[midRow][0]<=target && matrix[midRow][colNum-1]>=target){
                i = midRow;
                break;
            }
            if (matrix[midRow][colNum-1]<target){
                leftRow=midRow+1;
            }
            if (matrix[midRow][0]>target){
                rightRow=midRow-1;
            }
        }
        //没找到行，return false
        if(i== Integer.MAX_VALUE){
            return false;
        }
        //然后利用二分查找确定具体位置
        int left = 0;
        int right = colNum-1;
        
        while(left<=right){
            int mid = left+(right-left)/2;
            if(target == matrix[i][mid]){
                return true;
            }
            if(target>matrix[i][mid]){
                left=mid+1;
            }else{
                right=mid-1;
            }
        }
        return false;
    }
}
```

两次二分查找，首先一遍二分查找找到所在的行，再一次二分查找确定所在的列。如果矩阵的形状是m*n,那么时间复杂度就是O(logm+logn)
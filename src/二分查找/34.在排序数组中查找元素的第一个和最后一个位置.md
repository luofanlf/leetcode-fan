# 34.在排序数组中查找元素的第一个和最后一个位置

https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = 0;
        int right = nums.length-1;
        int lowerBound= getLowerBound(nums,target);
        int upperBound = getUpperBound(nums,target);
        if(lowerBound>=nums.length||upperBound<0||nums[lowerBound]!=target||nums[upperBound]!=target){
            return new int[]{-1,-1};
        }
        return new int[]{lowerBound,upperBound};

    }

    private int getLowerBound(int[] nums,int target){
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            int mid = left+(right-left)/2;
            if(nums[mid]<target){
                left=mid+1;
            }else{
                right=mid-1;
            }
        }
        return left;
    }

    private int getUpperBound(int[] nums,int target){
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            int mid = left+(right-left)/2;
            if(nums[mid]<=target){
                left=mid+1;
            }else{
                right=mid-1;
            }
        }
        return right;
    }
}
```

两次二分查找，分别找出等于target的区间的下边界和上边界：查找下边界时，应当在nums[mid]>=target的情况下，不断收缩right，最终left所指向的位置就是下边界。而上边界时，则需要在nums[mid]<=target的情况下收缩left，最终right指向上边界。



getlowerBound:

当target<nums[mid]时，左边界右移至left=mid+1，即target>nums[left-1]

当target<=nums[mid]时，右边界左移至right=mid-1，即target<=nums[right+1]

当循环结束时，left=rigth+1

因此有0.....left-1<target,target<=left.....n,

所以right是target区间的下边界



getupperBound:

当target>=nums[mid]时，左边界右移至left=mid+1，即target>=nums[left-1]

当target<nums[mid]时，右边界左移至right=mid-1，即target<nums[right+1]

当循环结束时，right=left-1

因此有0.....right<=target,target<right+1.....n,

所以right是target区间的上边界
# [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length-1;   
        int pivot = -1;
        for(int i = n-1;i>=0;i--){
            if(nums[i]<nums[i+1]){
                pivot = i;
                break;   
            }
        }
        if(pivot == -1){
            reverse(nums,0,n);
            return;
        }
        //找到用于交换的数
        for(int i = n;i>pivot;i--){     
            if(nums[i]>nums[pivot]){
                int temp = nums[i];
                nums[i] = nums[pivot];
                nums[pivot] = temp; 
                break;      
            }
        }

        reverse(nums,pivot+1,n);
    }


    public void reverse(int[] nums,int left,int right){
        while(left<right){
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            left++;
            right--;
        }
    }
}
```

1，2，3，4，5   ->   1，2，3，5，4 - > 1，2，4，3，5

我们想要找到字典序的下一个排列，所以就是想找到一个比当前数组刚好大一点点的数组，也就是说我们希望在保证前面的数字不动的情况下，改动的位置能够越靠右越好（那么如何让字典序增大呢，我们肯定需要对当前位置的某个数用后面位置更大的数来替换，并且这个位置靠越右越好，这也就是为什么如果整个数组都是倒序的也就字典序达到最大，因为不存在一个位置有后面风大的数字可以换到前面来了）。

因此我们可以从右往左寻找，如果数字一直是降序的，则后面没有能用来让当前位置改动而变大字典序的数字，因此我们需要找到第一个位置pivot使得nums[pivot]<nums[pivot+1];如果找不到说明整个数组都是降序的，直接reverse即可；找到pivot后，[pivot+1.....end]这一段一定是满足降序的，因此我们从右往左找到第一个大于nums[pivot]的数然后交换他和nums[pivot],交换后由于pivot更新，我们要保证[pivot+1...end]这一段降序的字典序最小，直接reverse成升序的即可。
# 84.柱状图中最大的矩形

https://leetcode.cn/problems/largest-rectangle-in-histogram/description/?envType=study-plan-v2&envId=top-100-liked

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Deque<Integer> stack = new ArrayDeque<>();
        int num = heights.length;
        int[] right = new int[num];
        int[] left = new int[num];
        Arrays.fill(left, -1);
        Arrays.fill(right, num);
        //每个高度右边的第一个小于其高度的索引的数组
        for(int i = 0;i<num;i++){
            while(!stack.isEmpty()&&heights[i]<heights[stack.peek()]){
                int index = stack.pop();
                right[index] = i;
            }
            stack.push(i);
        }
        //每个高度左边的第一个小于其高度的索引的数组
        stack = new ArrayDeque<>();
        for(int i = num-1;i>=0;i--){
            while(!stack.isEmpty()&&heights[i]<heights[stack.peek()]){
                int index = stack.pop();
                left[index] = i;
            }
            stack.push(i);
        }
        int max = 0;
        for(int i = 0;i<num;i++){
            int v = (right[i]-left[i]-1)*heights[i];
            max = Math.max(max,v);
        }
        return max;
    }
}
```

对于每个柱子的高度i，其确定的最大矩形的面积等于高度i乘宽度（其两端第一个小于高度i的柱子之间的距离），因此我们需要找到每个柱子左边与右边的第一个小于其高度的柱子，记录下他的索引。声明两个数组，分别存放索引对应的左边和右边的第一个小于其高度的柱子的索引，并且用-1和num来初始化数组（假设柱子从左到右递减，那么所有的柱子左侧应该找不到比他小的，可以一直延伸到最左边）。用单调栈来确定第一个小于其的柱子的索引，如果栈为空或者高度大于栈顶索引对应的高度，则入栈；如果小于栈顶高度，则弹出元素使栈重新单调，并且更新弹出的索引的对应的left或者right（新入栈的这个元素就对应着他们左边或者右边的第一个小于他们的柱子）